{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "additionalProperties": false,
    "description": "A pool manages a group of backend nodes. It routes traffic to the most appropriate node, based on load balancing and session persistence criteria.",
    "id": "/rvbd-schema/tm/2.0/config/active/pools#update",
    "javaType": "org.rackspace.stingray.pojo.pool.Pool",
    "properties": {
        "properties": {
            "additionalProperties": false,
            "properties": {
                "auto_scaling": {
                    "additionalProperties": false,
                    "properties": {
                        "cloud_credentials": {
                            "description": "The Cloud Credentials object containing authentication credentials to use in cloud API calls.",
                            "type": "string"
                        },
                        "cluster": {
                            "description": "The ESX host or ESX cluster name to put the new virtual machine instances on.",
                            "type": "string"
                        },
                        "data_center": {
                            "description": "The name of the logical datacenter on the vCenter server. Virtual machines will be scaled up and down under the datacenter root folder.",
                            "type": "string"
                        },
                        "data_store": {
                            "description": "The name of the datastore to be used by the newly created virtual machine.",
                            "type": "string"
                        },
                        "enabled": {
                            "description": "Are the nodes of this pool subject to auto-scaling?  If yes, nodes will be automatically added and removed from the pool by the chosen auto-scaling mechanism.",
                            "type": "boolean"
                        },
                        "external": {
                            "description": "Whether or not auto-scaling is being handled by an external system. Set this value to true if all aspects of auto-scaling are handled by an external system, such as RightScale. If set to false, the traffic manager will determine when to scale the pool and will communicate with the cloud provider to create and destroy nodes as necessary.",
                            "type": "boolean"
                        },
                        "hysteresis": {
                            "description": "The time period in seconds for which a change condition must persist before the change is actually instigated.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "imageid": {
                            "description": "The identifier for the image of the instances to create.",
                            "type": "string"
                        },
                        "ips_to_use": {
                            "description": "Which type of IP addresses on the node to use.  Choose private IPs if the traffic manager is in the same cloud as the nodes, otherwise choose public IPs.",
                            "type": "string"
                        },
                        "last_node_idle_time": {
                            "description": "The time in seconds for which the last node in an auto-scaled pool must have been idle before it is destroyed.  This is only relevant if min_nodes is 0.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_nodes": {
                            "description": "The maximum number of nodes in this auto-scaled pool.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "min_nodes": {
                            "description": "The minimum number of nodes in this auto-scaled pool.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "name": {
                            "description": "The beginning of the name of nodes in the cloud that are part of this auto-scaled pool.",
                            "type": "string"
                        },
                        "port": {
                            "description": "The port number to use for each node in this auto-scaled pool.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "refractory": {
                            "description": "The time period in seconds after the instigation of a re-size during which no further changes will be made to the pool size.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "response_time": {
                            "description": "The expected response time of the nodes in ms.  This time is used as a reference when deciding whether a node's response time is conforming.  All responses from all the nodes will be compared to this reference and the percentage of conforming responses is the base for decisions about scaling the pool up or down.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "scale_down_level": {
                            "description": "The fraction, in percent, of conforming requests above which the pool size is decreased.  If the percentage of conforming requests exceeds this value, the pool is scaled down.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "scale_up_level": {
                            "description": "The fraction, in percent, of conforming requests below which the pool size is increased.  If the percentage of conforming requests drops below this value, the pool is scaled up.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "size_id": {
                            "description": "The identifier for the size of the instances to create.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "basic": {
                    "additionalProperties": false,
                    "properties": {
                        "bandwidth_class": {
                            "description": "The Bandwidth Management Class this pool uses, if any.",
                            "type": "string"
                        },
                        "disabled": {
                            "description": "A list of nodes in the pool that are in the 'disabled' state.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "draining": {
                            "description": "A list of nodes in the pool that are in the 'draining' state.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "failure_pool": {
                            "description": "If all of the nodes in this pool have failed, then requests can be diverted to another pool.",
                            "type": "string"
                        },
                        "max_connection_attempts": {
                            "description": "The maximum number of nodes to which the traffic manager will attempt to send a request before returning an error to the client. Requests that are non-retryable will be attempted against only one node. Zero signifies no limit.",
                            "maximum": 99999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_idle_connections_pernode": {
                            "description": "The maximum number of unused HTTP keepalive connections that should be maintained to an individual node.  Zero signifies no limit.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_timed_out_connection_attempts": {
                            "description": "The maximum number of connection attempts the traffic manager will make where the server fails to respond within the time limit defined by the \"max_reply_time\" setting. Zero signifies no limit.",
                            "maximum": 99999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "monitors": {
                            "description": "The monitors assigned to this pool, used to detect failures in the back end nodes.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "node_connection_attempts": {
                            "description": "The number of times the software will attempt to connect to the same back-end node before marking it as failed.  This is only used when \"passive_monitoring\" is enabled.",
                            "maximum": 100,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "nodes": {
                            "description": "A list of all active and draining nodes in this pool.  A node should be specified as a \"<ip>:<port>\" pair.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "note": {
                            "description": "A description of the pool.",
                            "type": "string"
                        },
                        "passive_monitoring": {
                            "description": "Whether or not the software should check that 'real' requests (i.e. not those from monitors) to this pool appear to be working.  This should normally be enabled, so that when a node is refusing connections, responding too slowly, or sending back invalid data, it can mark that node as failed, and stop sending requests to it. <br>If this is disabled, you should ensure that suitable health monitors are configured to check your servers instead, otherwise failed requests will not be detected and subsequently retried.",
                            "type": "boolean"
                        },
                        "persistence_class": {
                            "description": "The default Session Persistence class this pool uses, if any.",
                            "type": "string"
                        },
                        "transparent": {
                            "description": "Whether or not connections to the back-ends appear to originate from the source client IP address.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "connection": {
                    "additionalProperties": false,
                    "properties": {
                        "max_connect_time": {
                            "description": "How long the pool should wait for a connection to a node to be established before giving up and trying another node.",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "max_connections_per_node": {
                            "description": "The maximum number of concurrent connections allowed to each back-end node in this pool per machine. A value of 0 means unlimited connections.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_queue_size": {
                            "description": "The maximum number of connections that can be queued due to connections limits. A value of 0 means unlimited queue size.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_reply_time": {
                            "description": "How long the pool should wait for a response from the node before either discarding the request or trying another node (retryable requests only).",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "queue_timeout": {
                            "description": "The maximum time to keep a connection queued in seconds.",
                            "maximum": 31536000,
                            "minimum": 0,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "ftp": {
                    "additionalProperties": false,
                    "properties": {
                        "support_rfc_2428": {
                            "description": "Whether or not the backend IPv4 nodes understand the EPRT and EPSV command from RFC 2428.  It is always assumed that IPv6 nodes support these commands.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "http": {
                    "additionalProperties": false,
                    "properties": {
                        "keepalive": {
                            "description": "Whether or not the pool should maintain HTTP keepalive connections to the nodes.",
                            "type": "boolean"
                        },
                        "keepalive_non_idempotent": {
                            "description": "Whether or not the pool should maintain HTTP keepalive connections to the nodes for non-idempotent requests.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "load_balancing": {
                    "additionalProperties": false,
                    "properties": {
                        "algorithm": {
                            "description": "The load balancing algorithm that this pool uses to distribute load across its nodes.",
                            "type": "string"
                        },
                        "node_weighting": {
                            "description": "A table containing per-node weighting for use in some load balancing algorithms (weighted least connections and weighted round robin).",
                            "items": {
                                "additionalProperties": false,
                                "properties": {
                                    "node": {
                                        "description": "Node to which the weighting should be applied.",
                                        "type": "string"
                                    },
                                    "weight": {
                                        "description": "Weight for the node. The actual value in isolation does not matter: As long as it is a valid integer 1-100, the per-node weightings are calculated on the relative values between the nodes.",
                                        "maximum": 100,
                                        "minimum": 1,
                                        "type": "integer"
                                    }
                                },
                                "required": [
                                    "node",
                                    "weight"
                                ],
                                "type": "object"
                            },
                            "type": "array"
                        },
                        "priority_enabled": {
                            "description": "Enable priority lists.",
                            "type": "boolean"
                        },
                        "priority_nodes": {
                            "description": "Minimum number of highest-priority active nodes.",
                            "maximum": 65535,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "priority_values": {
                            "description": "A list of node priorities, higher values signify higher priority.  Priorities are specified using the format \"<ip>:<port>:<priority>\", if a priority is not specified for a node it is assumed to be \"1\".",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        }
                    },
                    "type": "object"
                },
                "node": {
                    "additionalProperties": false,
                    "properties": {
                        "close_on_death": {
                            "description": "Close all connections to a node once we detect that it has failed.",
                            "type": "boolean"
                        },
                        "retry_fail_time": {
                            "description": "The amount of time, in seconds, that a traffic manager will wait before re-trying a node that has been marked as failed by passive monitoring.",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "smtp": {
                    "additionalProperties": false,
                    "properties": {
                        "send_starttls": {
                            "description": "If we are encrypting traffic for an SMTP connection, should we upgrade to SSL using STARTTLS.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "ssl": {
                    "additionalProperties": false,
                    "properties": {
                        "client_auth": {
                            "description": "Whether or not a suitable certificate and private key from the SSL Client Certificates catalog be used if the back-end server requests client authentication.",
                            "type": "boolean"
                        },
                        "enable": {
                            "description": "Whether or not the pool should encrypt data before sending it to a back-end node.",
                            "type": "boolean"
                        },
                        "enhance": {
                            "description": "SSL protocol enhancements allow your traffic manager to prefix each new SSL connection with information about the client. This enables Riverbed Web Servers to run multiple SSL sites, and to discover the client's IP address. Only enable this if you are using nodes for this pool which are Riverbed Web Servers or Stingray Traffic Managers, whose virtual servers have the \"ssl_trust_magic\" setting enabled.",
                            "type": "boolean"
                        },
                        "send_close_alerts": {
                            "description": "Whether or not to send an SSL/TLS \"close alert\" when initiating a socket disconnection.",
                            "type": "boolean"
                        },
                        "server_name": {
                            "description": "Whether or not the software should use the TLS 1.0 server_name extension, which may help the back-end node provide the correct certificate. Enabling this setting will force the use of at least TLS 1.0.",
                            "type": "boolean"
                        },
                        "strict_verify": {
                            "description": "Whether or not strict certificate verification should be performed. This will turn on checks to disallow server certificates that don't match the server name, are self-signed, expired, revoked, or have an unknown CA.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "tcp": {
                    "additionalProperties": false,
                    "properties": {
                        "nagle": {
                            "description": "Whether or not Nagle's algorithm should be used for TCP connections to the back-end nodes.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "udp": {
                    "additionalProperties": false,
                    "properties": {
                        "accept_from": {
                            "description": "The IP addresses and ports from which responses to UDP requests should be accepted. \n If set to accept responses from a specific set of IP addresses, you will need to enter a CIDR Mask (such as 10.100.0.0/16).",
                            "type": "string"
                        },
                        "accept_from_mask": {
                            "description": "The CIDR mask that matches IPs we want to receive responses from.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        }
    },
    "title": "Pool",
    "type": "object"
}