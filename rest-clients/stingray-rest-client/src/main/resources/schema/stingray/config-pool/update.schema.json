{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "additionalProperties": false,
    "description": "The \"conf/pools\" directory contains configuration files for backend node pools.  The name of a file is the name of the pool it defines.  Pools can be configured under the \"Services > Pools\" section of the Admin Server UI or by using functions under the \"Pool\" section of the SOAP API and CLI.",
    "id": "/rvbd-schema/tm/3.3/config/active/pools#update",
    "javaType": "org.rackspace.stingray.pojo.pool.Pool",
    "properties": {
        "properties": {
            "additionalProperties": false,
            "properties": {
                "auto_scaling": {
                    "additionalProperties": false,
                    "properties": {
                        "cloud_credentials": {
                            "description": "The Cloud Credentials object containing authentication credentials to use in cloud API calls.",
                            "type": "string"
                        },
                        "cluster": {
                            "description": "The ESX host or ESX cluster name to put the new virtual machine instances on.",
                            "type": "string"
                        },
                        "data_center": {
                            "description": "The name of the logical datacenter on the vCenter server. Virtual machines will be scaled up and down under the datacenter root folder.",
                            "type": "string"
                        },
                        "data_store": {
                            "description": "The name of the datastore to be used by the newly created virtual machine.",
                            "type": "string"
                        },
                        "enabled": {
                            "description": "Are the nodes of this pool subject to autoscaling?  If yes, nodes will be automatically added and removed from the pool by the chosen autoscaling mechanism.",
                            "type": "boolean"
                        },
                        "external": {
                            "description": "Whether or not autoscaling is being handled by an external system. Set this value to Yes if all aspects of autoscaling are handled by an external system, such as RightScale. If set to No, the traffic manager will determine when to scale the pool and will communicate with the cloud provider to create and destroy nodes as necessary.",
                            "type": "boolean"
                        },
                        "extraargs": {
                            "description": "Any extra arguments to the autoscaling API. Each argument can be separated by comma. E.g in case of EC2, it can take extra parameters to the Amazon's RunInstance API say DisableApiTermination=false,Placement.Tenancy=default.",
                            "type": "string"
                        },
                        "hysteresis": {
                            "description": "The time period in seconds for which a change condition must persist before the change is actually instigated.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "imageid": {
                            "description": "The identifier for the image of the instances to create.",
                            "type": "string"
                        },
                        "ips_to_use": {
                            "description": "Which type of IP addresses on the node to use.  Choose private IPs if the traffic manager is in the same cloud as the nodes, otherwise choose public IPs.",
                            "enum": [
                                "private_ips",
                                "publicips"
                            ],
                            "type": "string"
                        },
                        "last_node_idle_time": {
                            "description": "The time in seconds for which the last node in an autoscaled pool must have been idle before it is destroyed.  This is only relevant if min_nodes is 0.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_nodes": {
                            "description": "The maximum number of nodes in this autoscaled pool.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "min_nodes": {
                            "description": "The minimum number of nodes in this autoscaled pool.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "name": {
                            "description": "The beginning of the name of nodes in the cloud that are part of this autoscaled pool.",
                            "type": "string"
                        },
                        "port": {
                            "description": "The port number to use for each node in this autoscaled pool.",
                            "maximum": 65535,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "refractory": {
                            "description": "The time period in seconds after the instigation of a re-size during which no further changes will be made to the pool size.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "response_time": {
                            "description": "The expected response time of the nodes in ms.  This time is used as a reference when deciding whether a node's response time is conforming.  All responses from all the nodes will be compared to this reference and the percentage of conforming responses is the base for decisions about scaling the pool up or down.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "scale_down_level": {
                            "description": "The fraction, in percent, of conforming requests above which the pool size is decreased.  If the percentage of conforming requests exceeds this value, the pool is scaled down.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "scale_up_level": {
                            "description": "The fraction, in percent, of conforming requests below which the pool size is increased.  If the percentage of conforming requests drops below this value, the pool is scaled up.",
                            "minimum": 0,
                            "type": "integer"
                        },
                        "securitygroupids": {
                            "description": "List of security group IDs to associate to the new EC2 instance.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "size_id": {
                            "description": "The identifier for the size of the instances to create.",
                            "type": "string"
                        },
                        "subnetids": {
                            "description": "List of subnet IDs where the new EC2-VPC instance(s) will be launched. Instances will be evenly distributed among the subnets. If the list is empty, instances will be launched inside EC2-Classic.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "addnode_delaytime": {
                            "description": "Added manually as this was not part of the schemas and required...",
                            "minimum": 0,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "basic": {
                    "additionalProperties": false,
                    "properties": {
                        "bandwidth_class": {
                            "description": "The Bandwidth Management Class this pool uses, if any.",
                            "type": "string"
                        },
                        "failure_pool": {
                            "description": "If all of the nodes in this pool have failed, then requests can be diverted to another pool.",
                            "type": "string"
                        },
                        "max_connection_attempts": {
                            "description": "The maximum number of nodes to which the traffic manager will attempt to send a request before returning an error to the client. Requests that are non-retryable will be attempted against only one node. Zero signifies no limit.",
                            "maximum": 99999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_idle_connections_pernode": {
                            "description": "The maximum number of unused HTTP keepalive connections that should be maintained to an individual node.  Zero signifies no limit.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_timed_out_connection_attempts": {
                            "description": "The maximum number of connection attempts the traffic manager will make where the server fails to respond within the time limit defined by the \"max_reply_time\" setting. Zero signifies no limit.",
                            "maximum": 99999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "monitors": {
                            "description": "The monitors assigned to this pool, used to detect failures in the back end nodes.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "node_close_with_rst": {
                            "description": "Whether or not connections to the back-end nodes should be closed with a RST packet, rather than a FIN packet. This avoids the TIME_WAIT state, which on rare occasions allows wandering duplicate packets to be safely ignored.",
                            "type": "boolean"
                        },
                        "node_connection_attempts": {
                            "description": "The number of times the software will attempt to connect to the same back-end node before marking it as failed.  This is only used when \"passive_monitoring\" is enabled.",
                            "maximum": 100,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "nodes_table": {
                            "description": "A table of all nodes in this pool. A node should be specified as a \"<ip>:<port>\" pair, and has a state, weight and priority.",
                            "items": {
                                "additionalProperties": false,
                                "properties": {
                                    "node": {
                                        "description": "A node is a combination of an ip address and port",
                                        "type": "string"
                                    },
                                    "priority": {
                                        "description": "The priority of the node, higher values signify higher priority. If a priority is not specified for a node it is assumed to be \"1\".",
                                        "minimum": 0,
                                        "type": "integer"
                                    },
                                    "source_ip": {
                                        "description": "The source address the Traffic Manager uses to connect to this node.",
                                        "type": "string"
                                    },
                                    "state": {
                                        "description": "The state of the pool, which can either be Active, Draining or Disabled",
                                        "enum": [
                                            "active",
                                            "disabled",
                                            "draining"
                                        ],
                                        "type": "string"
                                    },
                                    "weight": {
                                        "description": "Weight for the node. The actual value in isolation does not matter: As long as it is a valid integer 1-100, the per-node weightings are calculated on the relative values between the nodes.",
                                        "maximum": 100,
                                        "minimum": 1,
                                        "type": "integer"
                                    }
                                },
                                "required": [
                                    "node"
                                ],
                                "type": "object"
                            },
                            "type": "array"
                        },
                        "note": {
                            "description": "A description of the pool.",
                            "type": "string"
                        },
                        "passive_monitoring": {
                            "description": "Whether or not the software should check that 'real' requests (i.e. not those from monitors) to this pool appear to be working.  This should normally be enabled, so that when a node is refusing connections, responding too slowly, or sending back invalid data, it can mark that node as failed, and stop sending requests to it. <br>If this is disabled, you should ensure that suitable health monitors are configured to check your servers instead, otherwise failed requests will not be detected and subsequently retried.",
                            "type": "boolean"
                        },
                        "persistence_class": {
                            "description": "The default Session Persistence class this pool uses, if any.",
                            "type": "string"
                        },
                        "transparent": {
                            "description": "Whether or not connections to the back-ends appear to originate from the source client IP address.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "connection": {
                    "additionalProperties": false,
                    "properties": {
                        "max_connect_time": {
                            "description": "How long the pool should wait for a connection to a node to be established before giving up and trying another node.",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "max_connections_per_node": {
                            "description": "The maximum number of concurrent connections allowed to each back-end node in this pool per machine. A value of 0 means unlimited connections.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_queue_size": {
                            "description": "The maximum number of connections that can be queued due to connections limits. A value of 0 means unlimited queue size.",
                            "maximum": 999999,
                            "minimum": 0,
                            "type": "integer"
                        },
                        "max_reply_time": {
                            "description": "How long the pool should wait for a response from the node before either discarding the request or trying another node (retryable requests only).",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        },
                        "queue_timeout": {
                            "description": "The maximum time to keep a connection queued in seconds.",
                            "maximum": 31536000,
                            "minimum": 0,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "dns_autoscale": {
                    "additionalProperties": false,
                    "properties": {
                        "enabled": {
                            "description": "When enabled, the Traffic Manager will periodically resolve the hostnames in the \"hostnames\" list using a DNS query, and use the results to automatically add, remove or update the IP addresses of the nodes in the pool.",
                            "type": "boolean"
                        },
                        "hostnames": {
                            "description": "A list of hostnames which will be used for DNS-derived autoscaling",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "port": {
                            "description": "The port number to use for each node when using DNS-derived autoscaling",
                            "maximum": 65535,
                            "minimum": 1,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "ftp": {
                    "additionalProperties": false,
                    "properties": {
                        "support_rfc_2428": {
                            "description": "Whether or not the backend IPv4 nodes understand the EPRT and EPSV command from RFC 2428.  It is always assumed that IPv6 nodes support these commands.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "http": {
                    "additionalProperties": false,
                    "properties": {
                        "keepalive": {
                            "description": "Whether or not the pool should maintain HTTP keepalive connections to the nodes.",
                            "type": "boolean"
                        },
                        "keepalive_non_idempotent": {
                            "description": "Whether or not the pool should maintain HTTP keepalive connections to the nodes for non-idempotent requests.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "kerberos_protocol_transition": {
                    "additionalProperties": false,
                    "properties": {
                        "principal": {
                            "description": "The Kerberos principal the traffic manager should use when performing Kerberos Protocol Transition.",
                            "type": "string"
                        },
                        "target": {
                            "description": "The Kerberos principal name of the service this pool targets.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "load_balancing": {
                    "additionalProperties": false,
                    "properties": {
                        "algorithm": {
                            "description": "The load balancing algorithm that this pool uses to distribute load across its nodes.",
                            "enum": [
                                "fastest_response_time",
                                "least_connections",
                                "perceptive",
                                "random",
                                "round_robin",
                                "weighted_least_connections",
                                "weighted_round_robin"
                            ],
                            "type": "string"
                        },
                        "priority_enabled": {
                            "description": "Enable priority lists.",
                            "type": "boolean"
                        },
                        "priority_nodes": {
                            "description": "Minimum number of highest-priority active nodes.",
                            "maximum": 65535,
                            "minimum": 1,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "node": {
                    "additionalProperties": false,
                    "properties": {
                        "close_on_death": {
                            "description": "Close all connections to a node once we detect that it has failed.",
                            "type": "boolean"
                        },
                        "retry_fail_time": {
                            "description": "The amount of time, in seconds, that a traffic manager will wait before re-trying a node that has been marked as failed by passive monitoring.",
                            "maximum": 99999,
                            "minimum": 1,
                            "type": "integer"
                        }
                    },
                    "type": "object"
                },
                "smtp": {
                    "additionalProperties": false,
                    "properties": {
                        "send_starttls": {
                            "description": "If we are encrypting traffic for an SMTP connection, should we upgrade to SSL using STARTTLS.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "ssl": {
                    "additionalProperties": false,
                    "properties": {
                        "client_auth": {
                            "description": "Whether or not a suitable certificate and private key from the SSL Client Certificates catalog be used if the back-end server requests client authentication.",
                            "type": "boolean"
                        },
                        "common_name_match": {
                            "description": "Added manually....",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "elliptic_curves": {
                            "description": "Added manually....",
                            "items": {
                                "type": "string"
                            },
                            "type": "array",
                            "uniqueItems": true
                        },
                        "enable": {
                            "description": "Whether or not the pool should encrypt data before sending it to a back-end node.",
                            "type": "boolean"
                        },
                        "enhance": {
                            "description": "SSL protocol enhancements allow your traffic manager to prefix each new SSL connection with information about the client. This enables Riverbed Web Servers to run multiple SSL sites, and to discover the client's IP address. Only enable this if you are using nodes for this pool which are Riverbed Web Servers or Stingray Traffic Managers, whose virtual servers have the \"ssl_trust_magic\" setting enabled.",
                            "type": "boolean"
                        },
                        "send_close_alerts": {
                            "description": "Whether or not to send an SSL/TLS \"close alert\" when initiating a socket disconnection.",
                            "type": "boolean"
                        },
                        "server_name": {
                            "description": "Whether or not the software should use the TLS 1.0 server_name extension, which may help the back-end node provide the correct certificate. Enabling this setting will force the use of at least TLS 1.0.",
                            "type": "boolean"
                        },
                        "signature_algorithms": {
                            "description": "The SSL signature algorithms preference list for SSL connections from this pool using TLS version 1.2 or higher. Leaving this empty will make the pool use the globally configured preference list, \"signature_algorithms\" in the \"ssl\" section of the \"global_settings\" resource.  See there and in the online help for how to specify SSL signature algorithms.",
                            "type": "string"
                        },
                        "ssl_ciphers": {
                            "description": "The SSL/TLS ciphers to allow for connections to a back-end node. Leaving this empty will make the pool use the globally configured ciphers, see configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!ssl3_ciphers\"> \"ssl!ssl3_ciphers\"</a> in the Global Settings section of the System tab.  See there for how to specify SSL/TLS ciphers.",
                            "type": "string"
                        },
                        "ssl_support_ssl2": {
                            "description": "Whether or not SSLv2 is enabled for this pool. Choosing the global setting means the value of the configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!support_ssl2\"> \"ssl!support_ssl2\"</a> from the Global Settings section of the System tab will be enforced.",
                            "enum": [
                                "disabled",
                                "enabled",
                                "use_default"
                            ],
                            "type": "string"
                        },
                        "ssl_support_ssl3": {
                            "description": "Whether or not SSLv3 is enabled for this pool. Choosing the global setting means the value of the configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!support_ssl3\"> \"ssl!support_ssl3\"</a> from the Global Settings section of the System tab will be enforced.",
                            "enum": [
                                "disabled",
                                "enabled",
                                "use_default"
                            ],
                            "type": "string"
                        },
                        "ssl_support_tls1": {
                            "description": "Whether or not TLSv1.0 is enabled for this pool. Choosing the global setting means the value of the configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!support_tls1\"> \"ssl!support_tls1\"</a> from the Global Settings section of the System tab will be enforced.",
                            "enum": [
                                "disabled",
                                "enabled",
                                "use_default"
                            ],
                            "type": "string"
                        },
                        "ssl_support_tls1_1": {
                            "description": "Whether or not TLSv1.1 is enabled for this pool. Choosing the global setting means the value of the configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!support_tls1_1\"> \"ssl!support_tls1_1\"</a> from the Global Settings section of the System tab will be enforced.",
                            "enum": [
                                "disabled",
                                "enabled",
                                "use_default"
                            ],
                            "type": "string"
                        },
                        "ssl_support_tls1_2": {
                            "description": "Whether or not TLSv1.2 is enabled for this pool. Choosing the global setting means the value of the configuration key <a href=\"?fold_open=SSL%20Configuration&section=Global%20Settings#a_ssl!support_tls1_2\"> \"ssl!support_tls1_2\"</a> from the Global Settings section of the System tab will be enforced.",
                            "enum": [
                                "disabled",
                                "enabled",
                                "use_default"
                            ],
                            "type": "string"
                        },
                        "strict_verify": {
                            "description": "Whether or not strict certificate verification should be performed. This will turn on checks to disallow server certificates that don't match the server name, are self-signed, expired, revoked, or have an unknown CA.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "tcp": {
                    "additionalProperties": false,
                    "properties": {
                        "nagle": {
                            "description": "Whether or not Nagle's algorithm should be used for TCP connections to the back-end nodes.",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "udp": {
                    "additionalProperties": false,
                    "properties": {
                        "accept_from": {
                            "description": "The IP addresses and ports from which responses to UDP requests should be accepted. \n If set to accept responses from a specific set of IP addresses, you will need to enter a CIDR Mask (such as 10.100.0.0/16).",
                            "enum": [
                                "all",
                                "dest_ip_only",
                                "dest_only",
                                "ip_mask"
                            ],
                            "type": "string"
                        },
                        "accept_from_mask": {
                            "description": "The CIDR mask that matches IPs we want to receive responses from.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        }
    },
    "title": "Pool",
    "type": "object"
}